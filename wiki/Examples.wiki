#summary Examples of common tasks in Software Construction Toolkit.

* Contents*
<wiki:toc max_depth="5" />

----
<wiki:comment> ----------------------------------------------------------------
-------------------------------------------------------------------------------
--------------------------------------------------------------- </wiki:comment>
= Environment setup =

Most of this takes place in main.scons, unless otherwise noted.

<wiki:comment> ------------------------------------------------ </wiki:comment>
== The Bare Minimum Main ==

The following is the smallest reasonable main.scons.
{{{
# Set up root environment with required component_setup tool and settings
# common to all platforms.
root_env = Environment(
    tools = ['component_setup'],
    BUILD_SCONSCRIPTS = ['hello.scons'],
)

# Derive a platform-specific environment and make this the default.
windows_opt_env = root_env.Clone(
    BUILD_TYPE = 'opt',
    BUILD_TYPE_DESCRIPTION = 'Windows optimized build',
    BUILD_GROUP = ['default'],
    tools = ['target_platform_windows', 'target_optimized'],
)

# Process the build environments
BuildEnvironments([windows_opt_env])
}}}

<wiki:comment> ------------------------------------------------ </wiki:comment>
== Single platform, debug and release builds ==

This extends the previous example to include debug and release builds.
{{{
# Set up root environment with required component_setup tool and settings
# common to all platforms.
root_env = Environment(
    tools = ['component_setup'],
    BUILD_SCONSCRIPTS = ['hello.scons'],
)

# Set up things common to all Windows builds
windows_env = root_env.Clone(tools = ['target_platform_windows'])

# Windows debug build
windows_dbg_env = windows_env.Clone(
    BUILD_TYPE = 'dbg',
    BUILD_TYPE_DESCRIPTION = 'Windows debug build',
    BUILD_GROUP = ['default'],
    tools = ['target_debug'],
)

# Windows optimized build
windows_opt_env = windows_env.Clone(
    BUILD_TYPE = 'opt',
    BUILD_TYPE_DESCRIPTION = 'Windows optimized build',
    tools = ['target_optimized'],
])

# Process the build environments
BuildEnvironments([windows_dbg_env, windows_opt_env])
}}}

<wiki:comment> ------------------------------------------------ </wiki:comment>
== Multiple platforms, debug and release builds ==

This extends the previous example to include multiple platforms.

Since the number of build environments is starting to grow, it is more
convenient to make a list of build environments and append to it rather than
constructing the list explicitly in the call to !BuildEnvironments().
{{{
# main.scons for hello, world
# Copyright 2008 Google Inc. All Rights Reserved.
# Author: rspangler@google.com (Randall Spangler)

build_environments = []

# Set up root environment with required component_setup tool and settings
# common to all platforms.
root_env = Environment(
    tools = ['component_setup'],
    BUILD_SCONSCRIPTS = ['hello.scons'],
)

#------------------------------------------------------------------------------
# Windows builds
windows_env = root_env.Clone(tools = ['target_platform_windows'])

# Windows debug build
windows_dbg_env = windows_env.Clone(
    BUILD_TYPE = 'dbg',
    BUILD_TYPE_DESCRIPTION = 'Windows debug build',
    BUILD_GROUP = ['default'],
    tools = ['target_debug'],
)
build_environments.append(windows_dbg_env)

# Windows optimized build
windows_opt_env = windows_env.Clone(
    BUILD_TYPE = 'opt',
    BUILD_TYPE_DESCRIPTION = 'Windows optimized build',
    tools = ['target_optimized'],
)
build_environments.append(windows_opt_env)

#------------------------------------------------------------------------------
# Linux builds
linux_env = root_env.Clone(tools = ['target_platform_linux'])

# Linux debug build
linux_dbg_env = linux_env.Clone(
    BUILD_TYPE = 'dbg',
    BUILD_TYPE_DESCRIPTION = 'Linux debug build',
    BUILD_GROUP = ['default'],
    tools = ['target_debug'],
)
build_environments.append(linux_dbg_env)

# Linux optimized build
linux_opt_env = linux_env.Clone(
    BUILD_TYPE = 'opt',
    BUILD_TYPE_DESCRIPTION = 'Linux optimized build',
    tools = ['target_optimized'],
)
build_environments.append(linux_opt_env)

#------------------------------------------------------------------------------
# Process the build environments
BuildEnvironments(build_environments)
}}}
Note that both windows_dbg_env and linux_dbg_env have $BUILD_TYPE='dbg' and
are in the default $BUILD_GROUP.  This works because !BuildEnvironments()
only looks at environments which match the current host platform.  So on
Windows, typing 'hammer' will build windows_dbg_env, and on Linux, typing
'hammer' will build linux_dbg_env.

<wiki:comment> ------------------------------------------------ </wiki:comment>
== Add code coverage build ==

Code coverage is added as a cloned environment for each target platform where
coverage should be run.
{{{
# Windows coverage variant
environment_list.append(windows_opt_env.Clone(
    BUILD_TYPE = 'opt-coverage',
    BUILD_TYPE_DESCRIPTION='Windows coverage variant',
    tools = ['code_coverage']
))
}}}
This adds a 'coverage' target which will run all the unit tests and produce a
coverage file $COVERAGE_OUTPUT_FILE.  To run coverage in this above example:
{{{
hammer --mode=opt-coverage coverage
}}}

----
<wiki:comment> ----------------------------------------------------------------
-------------------------------------------------------------------------------
--------------------------------------------------------------- </wiki:comment>
= Tasks in SConscripts =

<wiki:comment> ------------------------------------------------ </wiki:comment>
== The Bare Minimum Build ==

The following is the smallest reasonable SConscript:
{{{
# Import calling environment
Import('env')

# Build a program
env.ComponentProgram('hello', 'hello.cpp')
}}}

<wiki:comment> ------------------------------------------------ </wiki:comment>
== Build a library ==

The following code builds a library which is static or shared, depending on
the default for the target platform.
{{{
inputs = [
    'a.cc',
    'b.cc',
    'c.cc',
]
env.ComponentLibrary('my_lib', inputs)
}}}
You can build this library at the command line using 'hammer my_lib'.

<wiki:comment> ------------------------------------------------ </wiki:comment>
== Build a static library ==

The following code builds a static library (.a or .lib)
{{{
inputs = [
    'a.cc',
    'b.cc',
    'c.cc',
]
env.ComponentLibrary('my_static_lib', inputs, COMPONENT_STATIC=True)
}}}

<wiki:comment> ------------------------------------------------ </wiki:comment>
== Build a shared library ==

The following code builds a shared library (.dylib, .dll, .so)
{{{
inputs = [
    'a.cc',
    'b.cc',
    'c.cc',
]
env.ComponentLibrary('my_shared_lib', inputs, COMPONENT_STATIC=False)
}}}
Programs which link against 'my_shared_lib' will automatically copy the
resulting shared library to their output directory.

<wiki:comment> ------------------------------------------------ </wiki:comment>
== Build an output DLL ==

If you are building a library which is not linked by any program (for example,
a browser plugin), use $COMPONENT_LIBRARY_PUBLISH to let hammer it should be
treated like a program (that is, it should replicate itself and any resources
and/or libraries it uses to $STAGING_DIR).  You can also clear
$COMPONENT_LIBRARY_LINK_SUFFIXES so that hammer doesn't attempt to publish the
library to $LIB_DIR for other programs to link against.
{{{
env.ComponentLibrary('some_plugin', 'foo.cc', COMPONENT_STATIC=False,
                     COMPONENT_LIBRARY_PUBLISH=True)
}}}
or
{{{
env.ComponentLibrary('some_plugin', 'foo.cc', COMPONENT_STATIC=False,
                     COMPONENT_LIBRARY_PUBLISH=True,
                     COMPONENT_LIBRARY_LINK_SUFFIXES=[])
}}}


<wiki:comment> ------------------------------------------------ </wiki:comment>
== Build a program ==

The following code builds a program (application).
{{{
inputs = [
    'a.cc',
    'b.cc',
    'c.cc',
]
env.ComponentProgram('my_program', inputs)
}}}
You can build this library at the command line using 'hammer my_program'.

<wiki:comment> ------------------------------------------------ </wiki:comment>
== Specify different input files based on platform ==

The following example shows building a program where the list of input files
differs based on the platform.
{{{
# Inputs for all platforms
inputs = [
    'a.cc',
    'b.cc',
    'c.cc',
]

if env.Bit('windows'):
  inputs += ['win_only.cc']

if env.Bit('linux'):
  inputs += ['linux_only.cc']

env.ComponentProgram('my_program', inputs)
}}}

<wiki:comment> ------------------------------------------------ </wiki:comment>
== Add windows resources to a target ==

This example shows compiling windows resources into a program.
{{{
# Inputs for all platforms
inputs = [
    'a.cc',
    'b.cc',
    'c.cc',
]

if env.Bit('windows'):
  inputs += env.RES('my_resources.rc')

env.ComponentProgram('my_program', inputs)
}}}

<wiki:comment> ------------------------------------------------ </wiki:comment>
== Run an external unit test ==

This example shows how to run a unit test program which was not built by
hammer - for example, a shell script or external python script.
{{{
# Running 'precompiled_tests/foo.exe -o foo.dat', creates foo.dat.
test_out = env.Command(['foo.dat'], ['precompiled_tests/foo.exe'],
                       '$SOURCE -o $TARGET')

# Add 'run_foo' as an alias for running that test, which is a medium test.
env.ComponentTestOutput('run_foo', test_out, COMPONENT_TEST_SIZE='medium')
}}}
Here's another example which runs a python unit test.
{{{
# Run 'bar.py' and save output to 'bar.out'.
test_out = env.Command(['bar.out'], ['bar.py'], '$PYTHON $SOURCE > $TARGET')

# Add 'run_bar' as an alias for running that test.
env.ComponentTestOutput('run_bar', test_out)
}}}

----
<wiki:comment> ------------------------------------------------ </wiki:comment>
<wiki:comment> ------------------------------------------------ </wiki:comment>
<wiki:comment> ------------------------------------------------ </wiki:comment>
= TODO =

We know we need examples for the following:
   * App, console
   * App, windowed
   * Test program
   * Test program, windowed
   * Create a smoke test group
   * Helper for a test program
      * That is, a program which assists a test program, but is not itself directly runnable.  For example, a test server such as a program which listens on a named pipe.
      * Also note use of $PYTHON and that the outputs should depend on the test script if it's not part of the inputs/sources.)
   * Disable a test program
   * Small test program
   * Add resources to a program
   * Mac app bundle
   * Browser plugin (mac / activeX / npapi / moz)
   * Target, where I need to compile some files with different options
   * Target, where I need to compile some/all files with exceptions enabled
   * Code coverage
   * Visual Studio solution + projects
   * Include source from somewhere outside of the project using addRepository()
      * Recommend making a variable for the to- directory if you're referencing a lot
      * Note addRepository is global, so if you need to reference it more than one place in your Sconscripts, bubble it up to the highest level.
   * Make a variant of a project (when to make a new mode vs. env.SetBitFromOption())
   * Chain to a sub-build-script, such as an IDL compile script
   * Chain to a sub-build which is also in hammer
   * Call a custom python function to do something (show how to make a tool in your project's site_scons)
   * Test program which needs additional input (env.Publish() it)
   * Checked-in third-party library (needs to env.Publish() itself for running, ala third_party.scons)